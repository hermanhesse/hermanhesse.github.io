[{"title":"JavaScript-note-JS对象","url":"/2021/02/10/JS对象/","content":"# JS对象\n\n## 构造\n\n对象是最基础的复合类型，它是一组属性的集合。对象有几种构造方式。\n\n- 通过字面量构造\n- 通过构造器构造\n- 通过原型构造\n\n```javascript\n//字面量\n{\n    let myObj={\n        name：\"akira\",\n        birthday:\"12-29\"\n    };\n}\n\n//构造器\n{\n    let myObj=new Object();\n    myObj.name='akira';\n    myObj.birthday='12-29';\n}\n\n//原型\n{\n    let myObj=Object.create({\n        name:\"akira\";\n        birthday:\"21-29\"\n    });\n}\n```\n\n## 构造器与类\n\nJavaScript是面向对象的编程对象，对象默认的构造器是Object，我们可以函数作为构造器或者定义class。\n\n```javascript\n//函数作为构造器\n{\n    function Vector2D(x,y){\n        this.x=x;\n        this.y=y;\n    }\n    const v =new Vector(3,4);\n    console.log(v);\n}\n\n//定义class\n{\n    class Vector2D{\n        constructor(x,y){\n            this.x=x;\n            this.y=y;\n        }\n    }\n    const v=new Vector(3,4);\n    console.log(v);\n}\n```\n\n## 属性\n\n对象的属性名可以是字符串或Symbol\n\n### 属性定义\n\n对象属性定义的Key可以用合法标识符、字符串或方括号 [ ] 中的表达式。如果是表达式，计算出的值应该是字符串或者Symbol。\n\n```javascript\n//属性定义\nconst data1={\n    foo:'foo',\n    bar:'bar',\n};\n//-不能为标识符，所以用字符串定义key\nconst data2={\n    'foo-bar':'foo bar',\n};\n//表达式\nconst foo='foo';\nconst data3={\n    [foo+'bar']:'foobar',\n};\n\nconsole.log(data1); //{foo: \"foo\", bar: \"bar\"}\nconsole.log(data2); //{foo-bar: \"foo bar\"}\nconsole.log(data3); //{foobar: \"foobar\"}\n\nconst id=Symbol('id');\nconst obj={[id]:'message'};\nconsole.log(obj); //{Symbol(id): \"message\"}\n```\n\n### 属性访问\n\n对对象指定属性的访问，有两种方式:\n\n- 如果属性名是合法的标识符，那么可以使用 **.** 操作符访问\n\n- 如果属性名是不合法的操作符，比如不符合标识符名的字符串或Symbol,或者属性名需要计算，那么我们可以通过 \n\n  [ ] 操作符访问。\n\n```javascript\nconst id=Symbol('id');\nconst data={\n        'foo-bar':'foo-bar',\n        [id]:'message',\n        '12':'result',\n    };\n\nconsole.log(data['foo-bar'],data[id],data[3*4]);\n//foo-bar message result\n\n//[]允许我们动态计算表达式的值作为属性名\n//这对于我们动态转换数据结构很有帮助。\nconst students=['张三','李四','王五'];\nconst scores=[70,100,80];\nconst result={};\n\nfor(let i=0;i<students.length;i++){\n        result[students[i]]=scores[i];\n}\nconsole.log(result);\n//{张三: 70, 李四: 100, 王五: 80}\n```\n\n### 属性遍历\n\n除了通过对象属性名[key]访问对应1的值，我们可以对属性的Key或value分别进行遍历。\n\n- 用for ...in遍历\n- 用for ...of遍历，\n\n```javascript\nconst scores2={\n\t'张三':80,\n\t'李四':100,\n\t'王五':60,\n};\n\t\nfor(let [name,score] of Object.entries(scores2)){\n\tconsole.log(name,score);\n}\n//output:张三 80  李四 100 王五 60\n```\n\n[`Object.entries()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/entries)\n\n返回给定对象自身可枚举属性的 `[key, value]` 数组。\n\n###  属性的增删改\n\n对象的属性可以动态添加，直接给对象属性赋值就可以，要将已有属性删除，可以用delete操作，通过in操作符,可以判断一个属性是否在对象上存在。\n\n```javascript\nconst data2={};\n\t\n//添加属性\ndata2.foo='foo';\ndata2['foo-bar']='foo-bar';\n\t\ndelete data2.foo;// 删除属性\nconsole.log(data2.foo,data2['foo-bar']);\n//undefined foo-bar\nconsole.log('foo' in data2,'foo-bar' in data2);\n// false true\n```\n\n## 原型\n\n对象原型能在实例中共享数据。原型是对象上的特殊属性，对象可以是通过原型来共享数据。\n\n- 通过Object. create共享\n- 通过构造器共享\n\n```javascript\n//通过Object.create共享\n{\n\tconst o={foo:'foo'};\n\tconst a=Object.create(o);\n\tconst b=Object.create(o);\n\ta.bar='bar1';\n\tb.bar='bar2';\n\tconsole.log(a.foo,a.bar); //foo, bar1\n\tconsole.log(b.foo,b.bar); //foo, bar2\n}\n\t\n//通过构造器的prototype属性访问原型\n{\n\tfunction Foo(message='foo'){\n\tthis.foo = message;\n    }\n    Foo.prototype.bar='bar';\n    const a=new Foo('foo1'),\n\t\t  b=new Foo('foo2');\n\tconsole.log(a.foo,b.bar); //foo, bar1\n\tconsole.log(b.foo,b.bar); //foo, bar2\n}\n```\n\n### 什么是原型,原型链？\n\nJavaScript 常被描述为一种**基于原型的语言 (prototype-based language)**——每个对象拥有一个**原型对象**，对象以其原型为模板、从原型继承方法和属性。原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为**原型链 (prototype chain)**，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。\n\n准确地说，这些属性和方法定义在Object的构造器函数(constructor functions)之上的`prototype`属性上，而非对象实例本身。\n\n###  原型链\n\n在JavaScript中，几乎所有对象都可以访问它的构造器上的原型对象，而这个原型对象本身又可以访问它自身的构造器上的原型对象，依次类推，就构成一个链式结构，被称为原型链。\n\n- 类型被定义在 `.prototype` 中\n- 用 `Object.create()` 来继承\n\n```javascript\nfunction Animal(){}\nAnimal.prototype={\n\teat(){console.log(\"I'm  eating\")}\n}\nfunction Person(){}\nPerson.prototype=new Animal()\n\t\nPerson.prototype.speak=function(){\n\tconsole.log('I can say something')\n}\n\t\nfunction Student(name){\n\tthis.name=name\n}\nStudent.prototype=new Person();\nStudent.prototype.study=function(){\n\tconsole.log(\"I'm learning~~~\")\n}\nconst student = new Student('张三')\nconsole.log(student.eat(),student.speak(),student.study())\n```\n\n## 类继承\n\n圆形类在JavaScript中起到了类继承的作用，而ES6之后，我们也可以直接用class的语法来实现类继承。\n\n```javascript\n//类继承实例\nclass Animal{\n\t eat(){\n\t\tconsole.log(\"I'm eating\")\n\t }\n}\n   \nclass Person extends Animal{\n\t  speaking(){\n\t\t console.log(\" I can say something\")\n\t }\n}\n   \nclass Student extends Person{\n\tstudy(){\n\t\tconsole.log(\" I'm studying~~\")\n\t }\n}\n   \nconst student1=new Student('herman')\nconsole.log(student1.eat(),student1.speaking(),student1.study())\n```\n\n## 访问器\n\n根据对象的其他属性或者别的数据的改变而改变的一类属性。\n\n### 访问器属性\n\n对象可定义访问器属性（Accessor Property）。\n\n- 使用get/set定义\n- 使用defineProperty / defineProperties 定义\n\n```javascript\nclass Vector2D{\n\tconstructor(x,y) {\n\t\tthis.x =x;\n\t\tthis.y =y;\n\t}\n\tget length(){\n\t\treturn Math.sqrt(this.x**2+this.y**2);\n\t}\n\tset length(len){\n\t\tconst scale=len/this.length;\n\t\tthis.x*=scale;\n\t\tthis.y*=scale;\n\t}\n}\n\nconst v1=new Vector2D(3,4);\nconsole.log(v1.x,v1.y,v1.length); // 3,4,5\n\nv1.length *=2;\nconsole.log(v1.x,v1.y,v1.length); // 6,8,10\n```\n\n## 描述符\n\n是一类特殊的对象，用来描述属性的访问特性。\n\n通过defineProperty/defineProperties定义属性可以指定属性描述符。通过设定对象的描述符来改变对象的属性。configurable、writable、enumerable来控制对象的行为和状态。给属性添加类型通过定义get、set或定义value。value和get、set之间设定二选一。\n\n***不可枚举就是for...in时不会显示出来***\n\n只设定get是无法给属性赋值的。\n\n```javascript\nconst obj=[];\nObject.defineProperties(obj,{\n\tfoo:{\n\t\tvalue:'foo',\n\t\twritable:true,\n\t\tconfigurable:true,\n\t},\n\tbar:{\n\t\tget(){return 'bar'},\n\t}\n});\n\nconsole.log(obj.foo,obj.bar);// foo bar\nobj.foo='foo2';\nconsole.log(obj.foo,obj.bar);// foo2 bar\ndelete obj.foo;\nconsole.log(obj.foo,obj.bar);// undefined  bar\n\n```\n\n\n\n### `props`\n\n要定义其可枚举属性或修改的属性描述符的对象。对象中存在的属性描述符主要有两种：数据描述符和访问器描述符（更多详情，请参阅[`Object.defineProperty()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)）。描述符具有以下键：\n\n- `configurable`\n\n  `true` 只有该属性描述符的类型可以被改变并且该属性可以从对应对象中删除。 **默认为 `false`**\n\n- `enumerable`\n\n  `true` 只有在枚举相应对象上的属性时该属性显现。 **默认为 `false`**\n\n- `value`\n\n  与属性关联的值。可以是任何有效的JavaScript值（数字，对象，函数等）。 **默认为 [`undefined`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined).**\n\n- `writable`\n\n  `true`只有与该属性相关联的值被[assignment operator](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Assignment_Operators)改变时。 **默认为 `false`**\n\n- `get`\n\n  作为该属性的 getter 函数，如果没有 getter 则为[`undefined`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined)。函数返回值将被用作属性的值。 **默认为 [`undefined`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined)**\n\n- `set`\n\n  作为属性的 setter 函数，如果没有 setter 则为[`undefined`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined)。函数将仅接受参数赋值给该属性的新值。 **默认为 [`undefined`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined)**\n\n## defineProperties\n\n通过defineProperties和属性描述符定义属性\n\n- 动态添加在对象上的普通属性默认是可删除、可写、可枚举的。\n- 定义再class上的普通属性默认是可删除、可写、不可枚举的。\n- 可以使用Object.getOwnPropertyDescriptors来获取属性描述符。\n\n**`Object.defineProperties()`** 方法直接在一个对象上定义新的属性或修改现有属性，并返回该对象。\n\n```javascript\nvar obj = {};\nObject.defineProperties(obj, {\n  'property1': {\n    value: true,\n    writable: true\n  },\n  'property2': {\n    value: 'Hello',\n    writable: false\n  }\n  // etc. etc.\n});\n```\n\n\n\n## 解构\n\n对象初始化和赋值是可以解构。\n\n- 可以用属性名来解构\n- 也可以再解构的同时重新命名\n- 解构也可以嵌套\n- 除了一般对象，数组可以解构\n\n```javascript\n//数组的解构\nfunction f() {\n  return [1, 2];\n}\n\nvar a, b;\n[a, b] = f();\nconsole.log(a); // 1\nconsole.log(b); // 2\n```\n\n","tags":["javaScript"]},{"title":"JavaScript-note-JS函数","url":"/2021/02/04/JS函数/","content":"# JS函数\n\n## 函数声明\n\n可以通过function关键字来声明一个函数\n\n### function\n\n通过function关键字可以声明一个函数。\n\n- 函数声明没有块级作用域\n- 函数声明会被提升 ( hoist ) ,意思是调用函数可以在声明前调用\n\n一个**函数定义**（也称为**函数声明**，或**函数语句**）由一系列的[`function`](https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Statements/function)关键字组成，依次为：\n\n- 函数的名称。\n- 函数参数列表，包围在括号中并由逗号分隔。\n- 定义函数的 JavaScript 语句，用大括号`{}`括起来。\n\n```javascript\n//不带参数的函数\nfunction foo(){\n    console.log('foo bar');\n}\n\n//带有两个参数的函数\nfunction add(x,y=0){\n    return x+y;\n}\nconsole.log(add(1,2));//3\n\n//可选参数\nfunction sum(x=0,...rest){\n    return rest.reduce((a,b) => a+b,x);\n}\nconsole.log(sum(1,2,3,4,5));//15\n//解构参数\nfunction vectorlength({x=0,y=0,z=0}={}){\n    return Math.hypot(x,y,z);\n}\nconst v={x:3,y:4,z:0};\nconsole.log(vectorlength(v)); //5\n```\n\n## 函数表达式\n\n函数也是对象，因此我们可以把一个函数赋给一个变量。\n\n可以将函数作为对象使用\n\n- 函数表达式不会被提升 ( hoist ) ,不能在声明前调用函数\n- 函数表达式可以具名也可以匿名\n- 函数表达式具名只能在内部访问\n\n### 匿名函数\n\n​\tfunction关键字后面没有标识符的方式创建函数。\n\n```javascript\nvar functionName = function(arg0, arg1, arg2){ \n //函数体 \n};\n```\n\n## 箭头函数\n\n匿名函数表达式还可以写成箭头函数\n\n- 单行箭头可以省略花括号和return\n- 只有一个参数的箭头函数可以省略圆括号\n- 箭头函数不能具名，也没有this上下文\n\n```javascript\nconst angles=[30,45,60,90,180];\nconst radAngles=angles.map(\n    function(angle){\n        return Math.PI*angle/180\n    });\nconsole.log(radAngles);\n\n//箭头函数的写法\nconst radAngles=angles.map(\n    angle=>Math.PI*angle/180\n);\nconsole.log(radAngles);\n```\n\n## 执行上下文 ( 闭包 )\n\n函数有执行上下文，运行时会产生\"闭包\"。\n\n- 闭包是运行时由函数调用产生的\n- 通过闭包可访问执行上下文的数据\n- 如果产生闭包的引用被销毁，闭包被摧毁\n\n实例：\n\n```javascript\nfunction sayHelloTo(person){\n    return function(){\n        console.log('Hello  ${person}!');\n    }\n}\n\nlet greeting1=sayHelloTo('Tom');\nlet greeting2=sayHelloTo('Jerry');\n\ngreeting1();\ngreeting2();\n\ngreeting1=null;\ngreeting2=null;\n```\n\n**闭包**是指由全访问另一个函数作用中的变量的函数。床架你报的常见方式，就是在下一个函数内部创建另一个函数。\n\n## 动态绑定\n\nthis上下文在函数调用时可以动态指定，方法是通过函数的call、apply或bind方法来调用。\n\n```javascript\nconst person1={firstName:'三',lastName:'张'};\nconsole.log(getFullName.call(person1));// 张三\n\nconst logger ={\n    type:'info',\n    count:0,\n    log:function(message){\n        console[this.type](message,++this.count);\n    },\n}\n\n//call apply,bind 不能绑定this上下文，还能绑定部分参数\nsetInterval(logger.log.bind(logger,'heart beat'),1000);\n```\n\n## Function方法\n\n[`Function.prototype.apply()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply)\n\n在一个对象的上下文中应用另一个对象的方法;参数能够以数组形式传入。\n\n[`Function.prototype.bind()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind)\n\nbind（）方法会创建一个新函数，称为绑定函数。当调用这个绑定函数是，绑定函数会以创建它时传入bind（）方法的第一个参数作为this，传入bind（）方法的第一个\n\n[`Function.prototype.call()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call)\n\n在一个对象的上下文中应用另一个对象的方法；参数能够以列表形式传入。\n\n```javascript\nconst person1={firstName:'三',lastName:'张'};\nconsole.log(getFullName.call(person1));// 张三\n\nconst logger ={\n    type:'info',\n    count:0,\n    log:function(message){\n        console[this.type](message,++this.count);\n    },\n}\n\n//call apply,bind 不能绑定this上下文，还能绑定部分参数\nsetInterval(logger.log.bind(logger,'heart beat'),1000);\n```\n\n## Function类\n\n函数是Function类的实例。我们可以用Function类动态创建函数对象。\n\n```javascript\nconst sum = new Function('a', 'b', 'return a + b');\n\nconsole.log(sum(2, 6));\n// expected output: 8\n```\n\n`Function` 创建的函数只能在全局作用域中运行。\n\n### 语法\n\n> new Function ([arg1[, arg2[, ...argN]],] functionBody)\n\narg1, arg2, ... arg*N* 是被函数使用的参数的名称必须是合法命名的。\n\nfunctionBody是一个含有包括函数定义的 JavaScript 语句的**字符串**。\n\n在使用call()方法时，传递给函数的参数必须逐个列举出来\n\n```javascript\nfunction sum(num1, num2){ \n return num1 + num2; \n} \nfunction callSum(num1, num2){ \n return sum.call(this, num1, num2); \n} \nalert(callSum(10,10)); //20\n```\n\napply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组\n\n```javascript\nfunction sum(num1, num2){ \n return num1 + num2; \n} \nfunction callSum1(num1, num2){ \n return sum.apply(this, arguments); // 传入 arguments 对象\n} \nfunction callSum2(num1, num2){ \n return sum.apply(this, [num1, num2]); // 传入数组\n} \nalert(callSum1(10,10)); //20 \nalert(callSum2(10,10)); //20\n```\n\n","tags":["javaScript"]},{"title":"JavaScript-note-JS原始类型","url":"/2021/02/03/JS原始类型/","content":"# JS原始类型\n\n## Null和Undefined\n\nnull和undefined是javascript的两种基本类型，它们分别只有一个值。\n\n- Null的值是null\n- Undefined的值是undefine\n- 非严格比较下，null == undefined\n\nundefined表示未初始化或未定义的值。\n\n ```javascript\nlet foo; //标量标识符被声明而未被初始化\nconsole.log(foo); //undefined\n\nfunction bar(a,b){\n    return [a,b]\n}\n//bar函数的弟二个形参没有传入实参\nconsole.log(bar(1)); //[1,undefined]\n\nlet sun = 0;\nfunction addSum(num){\n    sum+=num;\n}\n//addSum没有return值\nconsole.log(addSum(10));// undefined\n\n//访问p对象不存在的z属性\nlet p={x:1,y:2};\nconsole.log(p.z); //undefined\n ```\n\nnull表示不确定的值。\n\n```javascript\nlet foo=null;\nconsole.log(foo); //null\n```\n\n## Number\n\nnumber表示整数和浮点数\n\n- 是符合IEEE 754标准的64位浮点数\n- 整数有二进制、八进制、十进制和十六进制表示法\n- 可以用科学计数法表示\n- 精准表示的整数范围从-2^53^+1到 2^53^-1\n- 常量Number.MAX_SAFE_INTEGER=2^53^-1\n\n```javascript\n0\n7\n-3\n0b101  //二进制表示5，0b前缀表示二进制\n0o777  //八进制表示511,0o前缀表示八进制\n-0x7f //十六进制表示-127，0x前缀表示16进制\n3e9  //科学计数法表示3000000000\n\nlet n1= 10,\n    n2= Number.MAX_SAFE_INTEGER,\n    n3= 1,2;\nconsole.log(Number.MAX_SAFE_INTEGER(n1),\n           Number.isSafeInteger(n2),\n           //n3是浮点数不是整数，所以结果也为false\n           Number.isSafeInteger(n3),\n           Number.isSafeInteger(n2 + 1));\n//true.true,false,false\n```\n\n浮点数是可以表示小数\n\n- 规范规定浮点数的整数部分如果是0，0可以省略。\n- 浮点数也可以使用科学计数法。\n- 最大浮点数 Number.MAX_VALUE  // 1.7976931348623157e+308\n- 最小浮点数 Number.MIN_VALUE  //  5e-324\n- 浮点数精度 Number.EPSILON  //2.220446049250313e-16\n- 无穷大数 Infinity 可以为 Infinity == Number.MAX_VALUE * 2 == 1 / 0 ，也可以负数-Infinity\n\n## 运算精度问题\n\n浮点数运算存在精度问题，不论用 == 和 === 比较浮点数\n\n- **不可用相等比较浮点数**\n- **不可用相等比较浮点数**\n- **不可用相等比较浮点数**\n\n## NaN\n\n符号 NaN 表示 Not-a-Number。在计算的过程中，遇到无法表示为数值的情况，计算结果就会是 ' NaN ' 。\n\n- 如果两个数值是NaN，它们的比较结果是不等的。\n- Number.isNaN 判断\n- 用 Object.is 比较\n\n## +0和-0\n\n数值0有+0和-0两种形态，这两个值如果比较的化是相等的。但是如果它们作为除数进行运算，分别会得到+Infinity和-Infinity。\n\n同样，如果一个有限的正数除以Infinity和-infinity分别得到+0和-0。\n\n```javascript\nconsole.log(1/Infinity,1/-Infinity); // 0 -0\n```\n\n## Boolean\n\nBoolean类型表示逻辑真和逻辑假，它只有两个可选的值，分别是字面量true和false。\n\n- JS的比较操作返回布尔类型的结果\n- 做布尔判断时存在隐式类型转换\n- +0、-0、NaN、空串、undefined、null转为false\n\n## string\n\nJS使用一对单引号 ' ' 或一对双引号 \" \" 来表示字符串，单引号和双引号中间不能有换行符。\n\n- 支持特殊转义符和Unicode转义符\n- 由于HTML标签属性用双引号，所以JS字符串通常推荐用单引号。\n\n常见的转义符\n\n| 序列   | 代表字符                                                     |\n| ------ | ------------------------------------------------------------ |\n| \\0     | Null字符（\\u0000）                                           |\n| \\b     | 退格符（\\u0008）                                             |\n| \\t     | 水平制表符（\\u0009）                                         |\n| \\n     | 换行符（\\u000A）                                             |\n| \\v     | 垂直制表符（\\u000B）                                         |\n| \\f     | 换页符（\\u000C）                                             |\n| \\r     | 回车符（\\u000D）                                             |\n| \\\"     | 双引号（\\u0022）                                             |\n| \\'     | 撇号或单引号（\\u0027）                                       |\n| \\\\     | 反斜杠（\\u005C）                                             |\n| \\xXX   | 由 2 位十六进制数值 XX 指定的 Latin-1 字符                   |\n| \\uXXXX | 由 4 位十六进制数值 XXXX 指定的 Unicode 字符                 |\n| \\XXX   | 由 1~3 位八进制数值（000 到 377）指定的 Latin-1 字符，可表示 256个 字符。如 \\251 表示版本符号。注意，ECMAScript 3.0 不支持，考虑到兼容性不建议使用。 |\n\n## 处理字符\n\n字符串可以使用**Spread**操作符展开成字符数组。可以使用codePointAt方法来获得某位字符的Unicode码位。\n\n- Unicode码位以多字节Unicode编码表示一位字符\n- String.fromCodePoint方法可以将码位还原为字符串\n\n## 类型转化\n\n字符串可以与其他类型数据相互操作\n\n- +操作符触发其他的隐藏类型转化\n- Number.parseInt与Number.parseFloat\n- 显示类型转化\n- 对象的toString方法\n\n```javascript\nconsole.log([1+2,'1'+2,'1'-2]);\n// [3,\"12\",-1]\nconsole.log(Number.parseInt('100abc',2)); //4\nconsole.log(Number('0b100')); //4\nconsole.log(Number.parseFloat('12.3e10xx'));\n//1230000000000\n\nvar foo={ //对象的 toString方法\n    toString(){\n        return 'foo';\n    }\n};\n\nconsole.log(foo+'bar'); // foobar\n```\n\n## 字符串常用操作\n\n字符串内置常用方法\n\n- 字符串连接：用+连接即可，或使用join方法\n- 大小写转化：toUpperCase( ) 和toLowerCase( )\n- 逆序：reverse( )\n- 截取：slice(2,3)截取2,3之间的字符，substr(2,3)是指2后面三个字符。 例如 hello的slice(2,3)为 ‘ l ’ ,而substr为 ‘ llo ’ 。\n- 查找：indexof()\n- 替换：repalce()\n\n| 字符串方法    | 说明                                                         |\n| ------------- | ------------------------------------------------------------ |\n| charAt()      | 返回字符串中的第 n 个字符                                    |\n| charCodeAt()  | 返回字符串中的第 n 个字符的代码                              |\n| indexOf()     | 检索字符串                                                   |\n| lastIndexOf() | 从后向前检索一个字符串                                       |\n| match()       | 找到一个或多个正则表达式的匹配，能够找出所有匹配的子字符串，并以数组的形式返回 |\n| search()      | 检索与正则表达式相匹配的子串，search() 方法和 indexOf() 的功能是相同的，查找指定字符串第一次出现的位置。但是 search() 方法仅有一个参数，定义匹配模式。 |\n\nreplace() 方法的第二个参数可以使用函数，当匹配时会调用该函数，函数的返回值将作为替换文本使用，同时函数可以接收以`$`为前缀的特殊字符，用来引用匹配文本的相关信息。\n\n| 约定字符串                | 说明                                           |\n| ------------------------- | ---------------------------------------------- |\n| $1、$2、...、$99          | 与正则表达式中的第 1~99 个子表达式相匹配的文本 |\n| $&（美元符号+连字符）     | 与正则表达式相匹配的子字符串                   |\n| $’（美元符号+切换技能键） | 位于匹配子字符串左侧的文本                     |\n| $'（美元符号+单引号）     | 位于匹配字符串右侧的文本                       |\n| $$                        | 表示 $ 字符串                                  |\n\n## 多行文本\n\nES6之后，JS支持以一对反引号  **`** 表示多行文本，同时也是模板字符串。\n\n- 多行文本保留空白符\n- 多行文本时模板字符串，可以解析和替换内容\n\n```javascript\n{\n    let who='月影',what='月饼';\n    const tpl2=`${who}所做的${what}\n\t是全天下\n\t最好吃的`;\n    console.log(tpl2);\n}\n```\n\n## Symbol\n\nES6及之后的版本中引入的新原始数据类型。Symbol可以创建唯一标识。\n\n- 作为对象的key\n- Symbol.for 可以作为全局变量\n- Symbol.keyFor 取出其设置的关键字\n\n**symbol** 是一种基本数据类型 （[primitive data type](https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive)）。`Symbol()`函数会返回**symbol**类型的值，该类型具有静态属性和静态方法。它的静态属性会暴露几个内建的成员对象；它的静态方法会暴露全局的symbol注册，且类似于内建对象类，但作为构造函数来说它并不完整，因为它不支持语法：\"`new Symbol()`\"。\n\n每个从`Symbol()`返回的symbol值都是唯一的。一个symbol值能作为对象属性的标识符；这是该数据类型仅有的目的。\n\n## 私有属性\n\n新的语言标准中private field有些不理想，所以也可以采用Symbol来定义私有属性。\n\n```javascript\nconst size = Symbol('size');\n\nclass collection{\n    construcctor(){\n        this[size]=0;\n    }\n    \n    add(item){\n        this[this[size]]=item;\n        this[size]++;\n    }\n    \n    static sizeof(instance){\n        return instance[size];\n    }\n}\n\n```\n\n## 内置Symbol\n\nES6内置了一些有用的Symbol，可以用力控制对象的一些内部行为。\n\n- Symbol.iterator\n- Symbol.toPrimitive\n- Symbol.toStringTag\n\n#### 迭代 symbols\n\n[`Symbol.iterator`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator)\n\n一个返回一个对象默认迭代器的方法。被 `for...of` 使用。\n\n[`Symbol.asyncIterator`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/asyncIterator)\n\n一个返回对象默认的异步迭代器的方法。被 `for await of` 使用。\n\n#### 正则表达式 symbols\n\n[`Symbol.match`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/match)\n\n一个用于对字符串进行匹配的方法，也用于确定一个对象是否可以作为正则表达式使用。被 [`String.prototype.match()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/match) 使用。\n\n[`Symbol.replace`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/replace)\n\n一个替换匹配字符串的子串的方法. 被 [`String.prototype.replace()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace) 使用。\n\n[`Symbol.search`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/search)\n\n一个返回一个字符串中与正则表达式相匹配的索引的方法。被[`String.prototype.search()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/search) 使用。\n\n[`Symbol.split`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/split)\n\n一个在匹配正则表达式的索引处拆分一个字符串的方法.。被 [`String.prototype.split()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/split) 使用。\n\n#### 其他 symbols\n\n[`Symbol.hasInstance`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/hasInstance)\n\n一个确定一个构造器对象识别的对象是否为它的实例的方法。被 [`instanceof`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof) 使用。\n\n[`Symbol.isConcatSpreadable`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/isConcatSpreadable)\n\n一个布尔值，表明一个对象是否应该flattened为它的数组元素。被 [`Array.prototype.concat()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/concat) 使用。\n\n[`Symbol.unscopables`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/unscopables)\n\n拥有和继承属性名的一个对象的值被排除在与环境绑定的相关对象外。\n\n[`Symbol.species`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/species)\n\n一个用于创建派生对象的构造器函数。\n\n[`Symbol.toPrimitive`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive)\n\n一个将对象转化为基本数据类型的方法。\n\n[`Symbol.toStringTag`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toStringTag)\n\n用于对象的默认描述的字符串值。被 [`Object.prototype.toString()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString) 使用。\n\n迭代Symbol实例：\n\n```javascript\nClass Path{\n    constructor(){\n        this_points=[];\n    }\n    add(...points){\n        this._points.push(...points);\n    }\n    *[Symbol.iterator](){\n        yield *this._points;\n    }\n    get length(){\n        return this._points.length;\n    }\n}\n\nconst path=new path();\npath.add([1,1],[1,2],[2,3]);\nconsole.log(path.length);\n\nfor(let point in path){\n    console.log(point); //[1,1],[1,2],[2,3]\n}\n```\n\n## BigInt\n\nBigInt是JavaScript新的原始类型，可以精确表示大于2^53^ -1的整数\n\n- Bigint字面量：数字+n\n\n- BigInt运算:不能与Number直接进行运算\n\n- 显式类型转化：BigInt与Number相互转换\n\n  ## [构造器](https://developer.mozilla.org/zh-cn/docs/Web/JavaScript/Reference/Global_Objects/BigInt#构造器)\n\n  - `BigInt()`\n\n    创建[`BigInt`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt) 对象。\n\n  ## [静态方法](https://developer.mozilla.org/zh-cn/docs/Web/JavaScript/Reference/Global_Objects/BigInt#静态方法)\n\n  - [`BigInt.asIntN()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt/asIntN)\n\n    将 BigInt 值转换为一个 -2width-1 与 2width-1-1 之间的有符号整数。\n\n  - [`BigInt.asUintN()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt/asUintN)\n\n    将一个 BigInt 值转换为 0 与 2width-1 之间的无符号整数。\n\n    ## [语法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt/asUintN#语法)\n\n    ```\n    BigInt.asUintN(width, bigint);\n    ```\n\n    ### [参数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt/asUintN#参数)\n\n    - `width`\n\n      可存储整数的位数。\n\n    - `bigint`\n\n       要存储在指定位数上的整数。\n\n```javascript\nconst a=-1n;\nconst b=BigInt.asUnitN(16, a);\nconsole.log(b); // 65535n\n\nconst c =BigInt.asIntN(16, b-1n);\nconsole.log(c); // -2n\n```\n\n","tags":["javaScript"]},{"title":"JavaScript-note-值类型和引用类型","url":"/2021/02/01/基本类型和引用类型/","content":"# 基本类型和引用类型\n\n**基本类型**是指简单的数据段，例如：Boolean、String、Undefined、Null和Number。\n\n**引用值类型**是值那些可能由多个值构成的对象。\n\n**基本数据类型**是按照值访问的，因此可以操作保存在变量中实际的值。\n\n**引用值类型**是保存在内存中的对象，**JavaScript不允许直接访问内存中的位置**，意思是在操作对象时，实际上是在操作对象的引用而不是实际的对象。\n\n## 基本类型和引用类型的主要区别\n\n值类型：\n\n1. 占用空间固定，保存在栈中。\n2. 保存和复制的是值本身\n3. 使用typeof检测数据类型\n4. 基本数据类型是值类型\n\n引用类型：\n\n1. 占用空间不固定，保存在堆中\n2. 保存和复制的是指向对象的一个指针\n3. 使用instanceof检测数据类型\n4. 使用new()方法创造的对象是引用类型\n5. 可以为其添加属性和方法，也可以改变和删除其属性和方法。但是为其属性再添加一个属性后，再次访问则会出现undefined，因此只能给引用类型**动态添加属性**——避免再次访问，一边创建一边使用。\n\n```javaScript \nvar person = new Object(); \nperson.name = \"Nicholas\"; \nalert(person.name); //\"Nicholas\"\nvar name = \"Nicholas\"; \nname.age = 27; \nalert(name.age); //undefined\n```\n\n值类型和引用类型实例：\n\n```javascript\nlet x=20,y=30;\nfunction foo(a,b){\n    a++;\n    b++;\n    console.log([a, b]); // 21 31\n}\n\nfoo(x, y);\nconsole.log([x, y]); // 20 30\n\nconst obj={x: 20, y: 30};\nfunction foo2(obj){\n    obj.x++;\n    obj.y++;\n    console.log(obj); // 21 31\n}\n\nfoo2(obj);\nconsole.log(obj); // {x: 21,y: 31}\n```\n\n","tags":["javaScript"]},{"title":"Hello World","url":"/2021/01/25/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]