[{"title":"JavaScript-note-JS函数","url":"/2021/02/04/JS函数/","content":"# JS函数\n\n## 函数声明\n\n可以通过function关键字来声明一个函数\n\n### function\n\n通过function关键字可以声明一个函数。\n\n- 函数声明没有块级作用域\n- 函数声明会被提升 ( hoist ) ,意思是调用函数可以在声明前调用\n\n一个**函数定义**（也称为**函数声明**，或**函数语句**）由一系列的[`function`](https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Statements/function)关键字组成，依次为：\n\n- 函数的名称。\n- 函数参数列表，包围在括号中并由逗号分隔。\n- 定义函数的 JavaScript 语句，用大括号`{}`括起来。\n\n```javascript\n//不带参数的函数\nfunction foo(){\n    console.log('foo bar');\n}\n\n//带有两个参数的函数\nfunction add(x,y=0){\n    return x+y;\n}\nconsole.log(add(1,2));//3\n\n//可选参数\nfunction sum(x=0,...rest){\n    return rest.reduce((a,b) => a+b,x);\n}\nconsole.log(sum(1,2,3,4,5));//15\n//解构参数\nfunction vectorlength({x=0,y=0,z=0}={}){\n    return Math.hypot(x,y,z);\n}\nconst v={x:3,y:4,z:0};\nconsole.log(vectorlength(v)); //5\n```\n\n## 函数表达式\n\n函数也是对象，因此我们可以把一个函数赋给一个变量。\n\n可以将函数作为对象使用\n\n- 函数表达式不会被提升 ( hoist ) ,不能在声明前调用函数\n- 函数表达式可以具名也可以匿名\n- 函数表达式具名只能在内部访问\n\n### 匿名函数\n\n​\tfunction关键字后面没有标识符的方式创建函数。\n\n```javascript\nvar functionName = function(arg0, arg1, arg2){ \n //函数体 \n};\n```\n\n## 箭头函数\n\n匿名函数表达式还可以写成箭头函数\n\n- 单行箭头可以省略花括号和return\n- 只有一个参数的箭头函数可以省略圆括号\n- 箭头函数不能具名，也没有this上下文\n\n```javascript\nconst angles=[30,45,60,90,180];\nconst radAngles=angles.map(\n    function(angle){\n        return Math.PI*angle/180\n    });\nconsole.log(radAngles);\n\n//箭头函数的写法\nconst radAngles=angles.map(\n    angle=>Math.PI*angle/180\n);\nconsole.log(radAngles);\n```\n\n## 执行上下文 ( 闭包 )\n\n函数有执行上下文，运行时会产生\"闭包\"。\n\n- 闭包是运行时由函数调用产生的\n- 通过闭包可访问执行上下文的数据\n- 如果产生闭包的引用被销毁，闭包被摧毁\n\n实例：\n\n```javascript\nfunction sayHelloTo(person){\n    return function(){\n        console.log('Hello  ${person}!');\n    }\n}\n\nlet greeting1=sayHelloTo('Tom');\nlet greeting2=sayHelloTo('Jerry');\n\ngreeting1();\ngreeting2();\n\ngreeting1=null;\ngreeting2=null;\n```\n\n**闭包**是指由全访问另一个函数作用中的变量的函数。床架你报的常见方式，就是在下一个函数内部创建另一个函数。\n\n## 动态绑定\n\nthis上下文在函数调用时可以动态指定，方法是通过函数的call、apply或bind方法来调用。\n\n```javascript\nconst person1={firstName:'三',lastName:'张'};\nconsole.log(getFullName.call(person1));// 张三\n\nconst logger ={\n    type:'info',\n    count:0,\n    log:function(message){\n        console[this.type](message,++this.count);\n    },\n}\n\n//call apply,bind 不能绑定this上下文，还能绑定部分参数\nsetInterval(logger.log.bind(logger,'heart beat'),1000);\n```\n\n## Function方法\n\n[`Function.prototype.apply()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply)\n\n在一个对象的上下文中应用另一个对象的方法;参数能够以数组形式传入。\n\n[`Function.prototype.bind()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind)\n\nbind（）方法会创建一个新函数，称为绑定函数。当调用这个绑定函数是，绑定函数会以创建它时传入bind（）方法的第一个参数作为this，传入bind（）方法的第一个\n\n[`Function.prototype.call()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call)\n\n在一个对象的上下文中应用另一个对象的方法；参数能够以列表形式传入。\n\n```javascript\nconst person1={firstName:'三',lastName:'张'};\nconsole.log(getFullName.call(person1));// 张三\n\nconst logger ={\n    type:'info',\n    count:0,\n    log:function(message){\n        console[this.type](message,++this.count);\n    },\n}\n\n//call apply,bind 不能绑定this上下文，还能绑定部分参数\nsetInterval(logger.log.bind(logger,'heart beat'),1000);\n```\n\n## Function类\n\n函数是Function类的实例。我们可以用Function类动态创建函数对象。\n\n```javascript\nconst sum = new Function('a', 'b', 'return a + b');\n\nconsole.log(sum(2, 6));\n// expected output: 8\n```\n\n`Function` 创建的函数只能在全局作用域中运行。\n\n### 语法\n\n> new Function ([arg1[, arg2[, ...argN]],] functionBody)\n\narg1, arg2, ... arg*N* 是被函数使用的参数的名称必须是合法命名的。\n\nfunctionBody是一个含有包括函数定义的 JavaScript 语句的**字符串**。\n\n在使用call()方法时，传递给函数的参数必须逐个列举出来\n\n```javascript\nfunction sum(num1, num2){ \n return num1 + num2; \n} \nfunction callSum(num1, num2){ \n return sum.call(this, num1, num2); \n} \nalert(callSum(10,10)); //20\n```\n\napply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组\n\n```javascript\nfunction sum(num1, num2){ \n return num1 + num2; \n} \nfunction callSum1(num1, num2){ \n return sum.apply(this, arguments); // 传入 arguments 对象\n} \nfunction callSum2(num1, num2){ \n return sum.apply(this, [num1, num2]); // 传入数组\n} \nalert(callSum1(10,10)); //20 \nalert(callSum2(10,10)); //20\n```\n\n","tags":["javaScript"]},{"title":"JavaScript-note-JS原始类型","url":"/2021/02/03/JS原始类型/","content":"# JS原始类型\n\n## Null和Undefined\n\nnull和undefined是javascript的两种基本类型，它们分别只有一个值。\n\n- Null的值是null\n- Undefined的值是undefine\n- 非严格比较下，null == undefined\n\nundefined表示未初始化或未定义的值。\n\n ```javascript\nlet foo; //标量标识符被声明而未被初始化\nconsole.log(foo); //undefined\n\nfunction bar(a,b){\n    return [a,b]\n}\n//bar函数的弟二个形参没有传入实参\nconsole.log(bar(1)); //[1,undefined]\n\nlet sun = 0;\nfunction addSum(num){\n    sum+=num;\n}\n//addSum没有return值\nconsole.log(addSum(10));// undefined\n\n//访问p对象不存在的z属性\nlet p={x:1,y:2};\nconsole.log(p.z); //undefined\n ```\n\nnull表示不确定的值。\n\n```javascript\nlet foo=null;\nconsole.log(foo); //null\n```\n\n## Number\n\nnumber表示整数和浮点数\n\n- 是符合IEEE 754标准的64位浮点数\n- 整数有二进制、八进制、十进制和十六进制表示法\n- 可以用科学计数法表示\n- 精准表示的整数范围从-2^53^+1到 2^53^-1\n- 常量Number.MAX_SAFE_INTEGER=2^53^-1\n\n```javascript\n0\n7\n-3\n0b101  //二进制表示5，0b前缀表示二进制\n0o777  //八进制表示511,0o前缀表示八进制\n-0x7f //十六进制表示-127，0x前缀表示16进制\n3e9  //科学计数法表示3000000000\n\nlet n1= 10,\n    n2= Number.MAX_SAFE_INTEGER,\n    n3= 1,2;\nconsole.log(Number.MAX_SAFE_INTEGER(n1),\n           Number.isSafeInteger(n2),\n           //n3是浮点数不是整数，所以结果也为false\n           Number.isSafeInteger(n3),\n           Number.isSafeInteger(n2 + 1));\n//true.true,false,false\n```\n\n浮点数是可以表示小数\n\n- 规范规定浮点数的整数部分如果是0，0可以省略。\n- 浮点数也可以使用科学计数法。\n- 最大浮点数 Number.MAX_VALUE  // 1.7976931348623157e+308\n- 最小浮点数 Number.MIN_VALUE  //  5e-324\n- 浮点数精度 Number.EPSILON  //2.220446049250313e-16\n- 无穷大数 Infinity 可以为 Infinity == Number.MAX_VALUE * 2 == 1 / 0 ，也可以负数-Infinity\n\n## 运算精度问题\n\n浮点数运算存在精度问题，不论用 == 和 === 比较浮点数\n\n- **不可用相等比较浮点数**\n- **不可用相等比较浮点数**\n- **不可用相等比较浮点数**\n\n## NaN\n\n符号 NaN 表示 Not-a-Number。在计算的过程中，遇到无法表示为数值的情况，计算结果就会是 ' NaN ' 。\n\n- 如果两个数值是NaN，它们的比较结果是不等的。\n- Number.isNaN 判断\n- 用 Object.is 比较\n\n## +0和-0\n\n数值0有+0和-0两种形态，这两个值如果比较的化是相等的。但是如果它们作为除数进行运算，分别会得到+Infinity和-Infinity。\n\n同样，如果一个有限的正数除以Infinity和-infinity分别得到+0和-0。\n\n```javascript\nconsole.log(1/Infinity,1/-Infinity); // 0 -0\n```\n\n## Boolean\n\nBoolean类型表示逻辑真和逻辑假，它只有两个可选的值，分别是字面量true和false。\n\n- JS的比较操作返回布尔类型的结果\n- 做布尔判断时存在隐式类型转换\n- +0、-0、NaN、空串、undefined、null转为false\n\n## string\n\nJS使用一对单引号 ' ' 或一对双引号 \" \" 来表示字符串，单引号和双引号中间不能有换行符。\n\n- 支持特殊转义符和Unicode转义符\n- 由于HTML标签属性用双引号，所以JS字符串通常推荐用单引号。\n\n常见的转义符\n\n| 序列   | 代表字符                                                     |\n| ------ | ------------------------------------------------------------ |\n| \\0     | Null字符（\\u0000）                                           |\n| \\b     | 退格符（\\u0008）                                             |\n| \\t     | 水平制表符（\\u0009）                                         |\n| \\n     | 换行符（\\u000A）                                             |\n| \\v     | 垂直制表符（\\u000B）                                         |\n| \\f     | 换页符（\\u000C）                                             |\n| \\r     | 回车符（\\u000D）                                             |\n| \\\"     | 双引号（\\u0022）                                             |\n| \\'     | 撇号或单引号（\\u0027）                                       |\n| \\\\     | 反斜杠（\\u005C）                                             |\n| \\xXX   | 由 2 位十六进制数值 XX 指定的 Latin-1 字符                   |\n| \\uXXXX | 由 4 位十六进制数值 XXXX 指定的 Unicode 字符                 |\n| \\XXX   | 由 1~3 位八进制数值（000 到 377）指定的 Latin-1 字符，可表示 256个 字符。如 \\251 表示版本符号。注意，ECMAScript 3.0 不支持，考虑到兼容性不建议使用。 |\n\n## 处理字符\n\n字符串可以使用**Spread**操作符展开成字符数组。可以使用codePointAt方法来获得某位字符的Unicode码位。\n\n- Unicode码位以多字节Unicode编码表示一位字符\n- String.fromCodePoint方法可以将码位还原为字符串\n\n## 类型转化\n\n字符串可以与其他类型数据相互操作\n\n- +操作符触发其他的隐藏类型转化\n- Number.parseInt与Number.parseFloat\n- 显示类型转化\n- 对象的toString方法\n\n```javascript\nconsole.log([1+2,'1'+2,'1'-2]);\n// [3,\"12\",-1]\nconsole.log(Number.parseInt('100abc',2)); //4\nconsole.log(Number('0b100')); //4\nconsole.log(Number.parseFloat('12.3e10xx'));\n//1230000000000\n\nvar foo={ //对象的 toString方法\n    toString(){\n        return 'foo';\n    }\n};\n\nconsole.log(foo+'bar'); // foobar\n```\n\n## 字符串常用操作\n\n字符串内置常用方法\n\n- 字符串连接：用+连接即可，或使用join方法\n- 大小写转化：toUpperCase( ) 和toLowerCase( )\n- 逆序：reverse( )\n- 截取：slice(2,3)截取2,3之间的字符，substr(2,3)是指2后面三个字符。 例如 hello的slice(2,3)为 ‘ l ’ ,而substr为 ‘ llo ’ 。\n- 查找：indexof()\n- 替换：repalce()\n\n| 字符串方法    | 说明                                                         |\n| ------------- | ------------------------------------------------------------ |\n| charAt()      | 返回字符串中的第 n 个字符                                    |\n| charCodeAt()  | 返回字符串中的第 n 个字符的代码                              |\n| indexOf()     | 检索字符串                                                   |\n| lastIndexOf() | 从后向前检索一个字符串                                       |\n| match()       | 找到一个或多个正则表达式的匹配，能够找出所有匹配的子字符串，并以数组的形式返回 |\n| search()      | 检索与正则表达式相匹配的子串，search() 方法和 indexOf() 的功能是相同的，查找指定字符串第一次出现的位置。但是 search() 方法仅有一个参数，定义匹配模式。 |\n\nreplace() 方法的第二个参数可以使用函数，当匹配时会调用该函数，函数的返回值将作为替换文本使用，同时函数可以接收以`$`为前缀的特殊字符，用来引用匹配文本的相关信息。\n\n| 约定字符串                | 说明                                           |\n| ------------------------- | ---------------------------------------------- |\n| $1、$2、...、$99          | 与正则表达式中的第 1~99 个子表达式相匹配的文本 |\n| $&（美元符号+连字符）     | 与正则表达式相匹配的子字符串                   |\n| $’（美元符号+切换技能键） | 位于匹配子字符串左侧的文本                     |\n| $'（美元符号+单引号）     | 位于匹配字符串右侧的文本                       |\n| $$                        | 表示 $ 字符串                                  |\n\n## 多行文本\n\nES6之后，JS支持以一对反引号  **`** 表示多行文本，同时也是模板字符串。\n\n- 多行文本保留空白符\n- 多行文本时模板字符串，可以解析和替换内容\n\n```javascript\n{\n    let who='月影',what='月饼';\n    const tpl2=`${who}所做的${what}\n\t是全天下\n\t最好吃的`;\n    console.log(tpl2);\n}\n```\n\n## Symbol\n\nES6及之后的版本中引入的新原始数据类型。Symbol可以创建唯一标识。\n\n- 作为对象的key\n- Symbol.for 可以作为全局变量\n- Symbol.keyFor 取出其设置的关键字\n\n**symbol** 是一种基本数据类型 （[primitive data type](https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive)）。`Symbol()`函数会返回**symbol**类型的值，该类型具有静态属性和静态方法。它的静态属性会暴露几个内建的成员对象；它的静态方法会暴露全局的symbol注册，且类似于内建对象类，但作为构造函数来说它并不完整，因为它不支持语法：\"`new Symbol()`\"。\n\n每个从`Symbol()`返回的symbol值都是唯一的。一个symbol值能作为对象属性的标识符；这是该数据类型仅有的目的。\n\n## 私有属性\n\n新的语言标准中private field有些不理想，所以也可以采用Symbol来定义私有属性。\n\n```javascript\nconst size = Symbol('size');\n\nclass collection{\n    construcctor(){\n        this[size]=0;\n    }\n    \n    add(item){\n        this[this[size]]=item;\n        this[size]++;\n    }\n    \n    static sizeof(instance){\n        return instance[size];\n    }\n}\n\n```\n\n## 内置Symbol\n\nES6内置了一些有用的Symbol，可以用力控制对象的一些内部行为。\n\n- Symbol.iterator\n- Symbol.toPrimitive\n- Symbol.toStringTag\n\n#### 迭代 symbols\n\n[`Symbol.iterator`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator)\n\n一个返回一个对象默认迭代器的方法。被 `for...of` 使用。\n\n[`Symbol.asyncIterator`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/asyncIterator)\n\n一个返回对象默认的异步迭代器的方法。被 `for await of` 使用。\n\n#### 正则表达式 symbols\n\n[`Symbol.match`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/match)\n\n一个用于对字符串进行匹配的方法，也用于确定一个对象是否可以作为正则表达式使用。被 [`String.prototype.match()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/match) 使用。\n\n[`Symbol.replace`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/replace)\n\n一个替换匹配字符串的子串的方法. 被 [`String.prototype.replace()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace) 使用。\n\n[`Symbol.search`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/search)\n\n一个返回一个字符串中与正则表达式相匹配的索引的方法。被[`String.prototype.search()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/search) 使用。\n\n[`Symbol.split`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/split)\n\n一个在匹配正则表达式的索引处拆分一个字符串的方法.。被 [`String.prototype.split()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/split) 使用。\n\n#### 其他 symbols\n\n[`Symbol.hasInstance`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/hasInstance)\n\n一个确定一个构造器对象识别的对象是否为它的实例的方法。被 [`instanceof`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof) 使用。\n\n[`Symbol.isConcatSpreadable`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/isConcatSpreadable)\n\n一个布尔值，表明一个对象是否应该flattened为它的数组元素。被 [`Array.prototype.concat()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/concat) 使用。\n\n[`Symbol.unscopables`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/unscopables)\n\n拥有和继承属性名的一个对象的值被排除在与环境绑定的相关对象外。\n\n[`Symbol.species`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/species)\n\n一个用于创建派生对象的构造器函数。\n\n[`Symbol.toPrimitive`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive)\n\n一个将对象转化为基本数据类型的方法。\n\n[`Symbol.toStringTag`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toStringTag)\n\n用于对象的默认描述的字符串值。被 [`Object.prototype.toString()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString) 使用。\n\n迭代Symbol实例：\n\n```javascript\nClass Path{\n    constructor(){\n        this_points=[];\n    }\n    add(...points){\n        this._points.push(...points);\n    }\n    *[Symbol.iterator](){\n        yield *this._points;\n    }\n    get length(){\n        return this._points.length;\n    }\n}\n\nconst path=new path();\npath.add([1,1],[1,2],[2,3]);\nconsole.log(path.length);\n\nfor(let point in path){\n    console.log(point); //[1,1],[1,2],[2,3]\n}\n```\n\n## BigInt\n\nBigInt是JavaScript新的原始类型，可以精确表示大于2^53^ -1的整数\n\n- Bigint字面量：数字+n\n\n- BigInt运算:不能与Number直接进行运算\n\n- 显式类型转化：BigInt与Number相互转换\n\n  ## [构造器](https://developer.mozilla.org/zh-cn/docs/Web/JavaScript/Reference/Global_Objects/BigInt#构造器)\n\n  - `BigInt()`\n\n    创建[`BigInt`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt) 对象。\n\n  ## [静态方法](https://developer.mozilla.org/zh-cn/docs/Web/JavaScript/Reference/Global_Objects/BigInt#静态方法)\n\n  - [`BigInt.asIntN()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt/asIntN)\n\n    将 BigInt 值转换为一个 -2width-1 与 2width-1-1 之间的有符号整数。\n\n  - [`BigInt.asUintN()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt/asUintN)\n\n    将一个 BigInt 值转换为 0 与 2width-1 之间的无符号整数。\n\n    ## [语法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt/asUintN#语法)\n\n    ```\n    BigInt.asUintN(width, bigint);\n    ```\n\n    ### [参数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt/asUintN#参数)\n\n    - `width`\n\n      可存储整数的位数。\n\n    - `bigint`\n\n       要存储在指定位数上的整数。\n\n```javascript\nconst a=-1n;\nconst b=BigInt.asUnitN(16, a);\nconsole.log(b); // 65535n\n\nconst c =BigInt.asIntN(16, b-1n);\nconsole.log(c); // -2n\n```\n\n","tags":["javaScript"]},{"title":"JavaScript-note-值类型和引用类型","url":"/2021/02/01/基本类型和引用类型/","content":"# 基本类型和引用类型\n\n**基本类型**是指简单的数据段，例如：Boolean、String、Undefined、Null和Number。\n\n**引用值类型**是值那些可能由多个值构成的对象。\n\n**基本数据类型**是按照值访问的，因此可以操作保存在变量中实际的值。\n\n**引用值类型**是保存在内存中的对象，**JavaScript不允许直接访问内存中的位置**，意思是在操作对象时，实际上是在操作对象的引用而不是实际的对象。\n\n## 基本类型和引用类型的主要区别\n\n值类型：\n\n1. 占用空间固定，保存在栈中。\n2. 保存和复制的是值本身\n3. 使用typeof检测数据类型\n4. 基本数据类型是值类型\n\n引用类型：\n\n1. 占用空间不固定，保存在堆中\n2. 保存和复制的是指向对象的一个指针\n3. 使用instanceof检测数据类型\n4. 使用new()方法创造的对象是引用类型\n5. 可以为其添加属性和方法，也可以改变和删除其属性和方法。但是为其属性再添加一个属性后，再次访问则会出现undefined，因此只能给引用类型**动态添加属性**——避免再次访问，一边创建一边使用。\n\n```javaScript \nvar person = new Object(); \nperson.name = \"Nicholas\"; \nalert(person.name); //\"Nicholas\"\nvar name = \"Nicholas\"; \nname.age = 27; \nalert(name.age); //undefined\n```\n\n值类型和引用类型实例：\n\n```javascript\nlet x=20,y=30;\nfunction foo(a,b){\n    a++;\n    b++;\n    console.log([a, b]); // 21 31\n}\n\nfoo(x, y);\nconsole.log([x, y]); // 20 30\n\nconst obj={x: 20, y: 30};\nfunction foo2(obj){\n    obj.x++;\n    obj.y++;\n    console.log(obj); // 21 31\n}\n\nfoo2(obj);\nconsole.log(obj); // {x: 21,y: 31}\n```\n\n","tags":["javaScript"]},{"title":"Hello World","url":"/2021/01/25/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]